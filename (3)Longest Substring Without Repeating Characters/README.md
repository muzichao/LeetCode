#### 题目

给定一个字符串，找到无相同字符的最长子字符串，返回该子字符串的长度。

#### 示例

输入：`"abcabcbb"`

输出：`3`


输入：`"a"`

输出：`1`

输入：`"aaaaa"`

输出：`1`

#### 分析

思路1:

从第 i(i = 0,1,2,3,...) 个字符开始遍历，找到最长的无重复字符的子字符串，更新最长子字符串长度。

注意：

思路1中可能涉及许多重复操作。例如：对于字符串 s = “abcad”，在 i=0 时，子字符串“abc”满足无重复字符，“abca” 有重复字符，所以 i=1 的最长子字符串为 “abc”；当 i=1 时，由于不满足条件的字符出现在 s[3] = 'a'，与 s[0] = 'a'相同，则必定满足 s[1] -- s[3] 是不同的，就不用再判断了。

思路2:

1. 初始无重复字符区间为 ：str = s[0]
2. 从第 i(i = 1,2,3,...) 个字符开始遍历，更新无重复字符区间
    1. 假设满足条件的区间为[x,y](a b c d)
    2. 假设第 y+1 个元素与[x,y]中所有元素不同(a b c d e)，则新的区间为[x, y+1]
    3. 假设第 y+1 个元素与[x,y]中第k个元素相同(a b c d b)，则新的区间为[k+1, y+1]
3. 更新最长子字符串长度

#### 流程

1. 初始无重复字符区间为 ：s[0]
2. 从第 i(i = 1,2,3,...) 个字符开始遍历，更新无重复字符区间
    1. 假设满足条件的区间为[x,y](a b c d)
    2. 假设第 y+1 个元素与[x,y]中所有元素不同(a b c d e)，则新的区间为[x, y+1]
    3. 假设第 y+1 个元素与[x,y]中第k个元素相同(a b c d b)，则新的区间为[k+1, y+1]
3. 更新最长子字符串长度
