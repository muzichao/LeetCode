#### 题目

又一个m行n列的网格，从左上角向右下角移动，每次只能向下或向右移动，一次只能移动一格。每一个格子都有一个数字，每个路径上所有数字的和表示该路径的长度，求最短的路径。

#### 示例

输入：

  2 0 1
  2 2 1
  0 2 0

输出：`4`

也就是说从左上角的2，到右下角的0的最短路径为4: 2-0-1-1-0

#### 分析

    A a . . . 
    b C . . .
    . . . . .
    . . . . B

A到C的最小路径等于C加上a和b的较小值，也就是说：

    f(m, n) = Matrix(m, n) + min(f(m-1, n), f(m, n-1))

另外，当m=1,n=1时，f(m, n) = Matrix(m, n);

当m=1,n!=1时，f(m, n) = Matrix(m, n) + f(m, n-1);

当m!=1,n=1时，f(m, n) = Matrix(m, n) + f(m-1, n);

很明显，上述式子可以看成一个典型的递归问题，但是当m和n较大时，效率明显下降。

> 可以把递归问题转换为递推问题

  3 4 3 2 0
  1 2 4 0 4
  1 0 4 1 0
  3 1 0 3 2
  0 4 3 2 3

如上输入所示：

               n
         1  2  3  4  5
      1  3  7  10 12 12
      2  4  6  10 10 14
    m 3  5  5  9  10 10
      4  8  6  6  9  11
      5  8  10 9  11 14

由于当m=1，或者n=1时，f(m, n) = 1，所以上述矩阵的第一行和第一列都为1，此后的元素可以用下式推出:

    f(m, n) = f(m-1, n) + f(m, n-1)

> 事实上，只用开辟长度为n的数组就可以，因为在计算上述矩阵的第i行时，完全可以覆盖掉第i-1行。

#### 流程

1. 初始长度为n的全0数组
2. 初始化第一行数据
2. 当i = 1 到 m-1时
    从数组的第二个元素开始遍历：A[j] = Matrix(i,j) + min(A[j], A[j-1])
3. 返回A[n-1]
