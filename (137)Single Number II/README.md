#### 题目

给定一个数组，除了一个数出现1次之外，其余数都出现3次。找出出现一次的数。

> PS: 算法只能是线性时间的复杂度，并且不能使用额外的空间

#### 示例

输入：`[1, 2, 1, 2, 1, 2, 7]`
输出：`7`

#### 分析

方法1:

最简单的思路就是双重for循环，从起始位置开始遍历，看是否有与当前元素相同的元素。如果有则跳到下一元素，否则找到所求元素。

然而上述方法不满足计算复杂度的要求，因此需要另求它法。

方法2:

1. 相同数字的异或为0
2. 任意数字与0的异或等于本身
3. 异或满足交换律和结合率

其实异或可以等价于每一位对2进行取余操作。某一位上1出现偶数次则为0，出现奇数次则为1。所以，在一个数组里面，如果只有一个数出现1次，其余数都出现2次的情况可以通过对所有数异或得到这个只出现一次的数。类似的，如果每一位对3取余，0表示出现0次或3次，1表示出现1次，2表示出现两次，那么也就可以找到只出现一次的那个数。所以此时就需要额外的变量来表示出现的此时。

```cpp
    int ones = 0; //记录只出现过1次的bits
    int twos = 0; //记录只出现过2次的bits
    int threes = 0; //记录只出现过3次的bits

    twos |= ones&t; //要在更新ones前面更新twos
    ones ^= t; //异或标记只出现一次的bits
    threes = ones&twos; //ones和twos中都为1即出现了3次
    ones &= ~threes; //抹去出现了3次的bits
    twos &= ~threes; //抹去出现了3次的bits
```

#### 流程

1. 初始化ones，twos，threes为0
2. 从起始位置开始遍历
3. 用当前元素来更新每一位上1出现的此时
    1. 找出出现2次1的bits
    2. 找出出现1次1的bits
    3. 2次 + 1次 = 3次
    4. 清除ones和twos中出现三次的bits
4. 如果不是结束位置则转到下一个元素，执行3

