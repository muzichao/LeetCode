#### 题目

给定两个数组A和B（A的长度为m，B的长度为n），查找两个数组的中值。要求算法的时间复杂度为： `O(log(m+n))`

#### 示例

输入：A = [1, 3, 6, 8], B = [2, 4]

输出：3.5

输入：A = [1, 3, 6, 8], B = [2, 4, 5]

输出：4

#### 分析

如果数组总的元素个数 (m+n) 为奇数个，则中值就为中间元素的值；如果数组总的元素个数 (m+n) 为偶数个，则中值就为中间两个元素的平均值。

思路1:

由于数组A和B是有序的，因此可以利用选择排序的思路将A和B合并成一个有序数组，然后就可以直接求得中值，此时的时间复杂度为：O(m+n)

思路2:

上述问题可以转化为求这两个数组中第k小的元素的问题，如果数组总的元素个数 (m+n) 为奇数个，则中值就为第 (m+n)/2 小的元素；如果数组总的元素个数 (m+n) 为偶数个，则中值就为第 (m+n)/2 小的元素和第 (m+n)/2+1 小的元素的平均值。

那么，下面的问题就是如何求解第k小的元素呢？

总是假设m小于n(如果m大于n，只需将A和B互换就可以)：

1. 利用二分法的思想，在A中取 k/2 个数，在B中取 k-k/2 个数。由于 k/2 可能大于m，因此，在A中取 pa=min(m,k/2) 个数，在B中取 pb=k-pa 个数
2. 如果 A[pa]<B[pb]，可知，A[pa] 及之前的数必定都小于第k小的数。所以，只需在 A[pa+1] -- A[m] 之间，及 B[0] -- B[n] 之间查找第 pb 小的数（递归）
3. 反之，如果 A[pa]>B[pb]，B[pb] 及之前的数必定都小于第k小的数。所以，只需在 B[pb+1] -- B[n] 之间，及 A[0] -- A[m] 之间查找第 pa 小的数（递归）

> 在第2步中，由于pb必定小于n，所以只用查找 B[0] -- B[pb] 即可；在第3步中，pa必定小于等于m，只需查找  A[0] -- A[pa] 即可。

#### 流程

1. 判断 (m+n) 的奇偶性
    1. 如果为奇，返回第 (m+n)/2 小的元素；
    2. 如果为偶，返回第 (m+n)/2 小的元素和第 (m+n)/2+1 小的元素的平均值。
