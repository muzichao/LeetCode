#### 题目

输入一个 m x n 的矩阵，该矩阵具有一些特征：
1. 每一行都是升序排列
2. 每一行的第一个元素都大于上一行的最后一个元素

设计一个高效的算法，在该矩阵中查找一个元素。

#### 示例

输入矩阵：

    [
      [1,   3,  5,  7],
      [10, 11, 16, 20],
      [23, 30, 34, 50]
    ]

输入查找元素：`11`

输出：`false`

#### 分析

方法一：

最简单的方法，双重for循环，遍历查找。但是此方法太low，一点都不高效。

方法二：

因为每一行是有序的，因此可以先判断是否属于某一行，如果是，则用二分法查找；或者可以使用<algorithm>中的find函数查找。

> 至于属于哪一行，依然涉及遍历查找或者二分查找。


方法三：

矩阵中有 m x n 个元素，起始如果把该矩阵按行优先拉成一个一维数组，那么该数组也是有序的，可以考虑对整个数组进行二分查找。

> 此方法的劣势是：对每一个索引要其是属于哪一行哪一列，涉及除法和取余运算。其实，原始矩阵相当于已经把数组等分成n份，为何不利用呢。


#### 流程

1. 空矩阵，返回false
2. 用二分法查找元素所在区间（属于哪一行）
3. 在改行使用二分法查找（或者使用find函数）
