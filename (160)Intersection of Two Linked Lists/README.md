#### 题目

查找两个单链表的第一个交点，如果无交点，则返回`NULL`

#### 示例

输入：

    A:          a1 → a2
                       ↘
                         c1 → c2 → c3
                       ↗
    B:     b1 → b2 → b3

输出：`c1`

输入：

    A:        a1
                ↘
    B:          → b1

输出：`b1`

#### 分析

有四种不同的思路：

思路1:

使用暴力搜索法：通过双重for循环，从链表A的头结点开始遍历；然后在在链表B的头结点开始查找，是否链表A中的当前结点在链表B中。如果在，则返回，就是所求的第一个交点。

时间复杂度：O(mn)

空间复杂度：O(1)

思路2:

由于思路1中涉及反复的查找，因此可以利用STL的set或hash，也就是把结点指针存储在红黑树中，或者哈希表中，这样查找效率将大大增加。

时间复杂度：O(m*lg(n)) 或者 O(m)

空间复杂度：O(n)

> 上述是把链表B存储在红黑树或者哈希表，存储A类似


思路3:

上述两个思路要么时间复杂度高，要么空间复杂度高，那有没有一种线性时间复杂度，常数空间复杂度的方法呢，答案是肯定的。

在判断两个链表是否相交的时候，我们可以通过判断尾结点是否相同两个链表是否相交。那为什么无法找到第一个结点呢？`因为两个链表的长度不确定，无法确定第一个交点之前都有多少结点`？问题出来了，答案也就不言而喻了：可以先分别遍历链表A和链表B，计算链表A和B的结点个数，然后让其第一个结点前的结点个数相同，再同步移动，两个链表的第一个相同结点就是所求的第一个交点。

如示例1:

A链表结点个数为5，B链表结点个数为6。所以可以让B链表先移动（6-5=1）个结点，此时B的起始结点相当于`b2`，然后两个链表同时移动，第一个相同结点`c1`就是所求结点。

时间复杂度：O(m+n)

空间复杂度：O(1)

思路4:

思路3中通过分别计算两个链表的结点个数来实现链表的同步，那么是否有其他方法可以是两个链表同步呢？答案是肯定的。我们知道：m+n = n+m，所以示例1可以转换为：

    A:          a1 → a2 → c1 → c2 → c3   →  b1 → b2 → b3 → c1 → c2 → c3
    B:          b1 → b2 → b3 → c1 → c2 → c3  →   a1 → a2 → c1 → c2 → c3


上面的意思就是说，把B链表接在A链表的后面，把A链表接在B链表的后面，此时两个链表的长度就相同的。

此时，分别从A和B的头结点开始同步遍历，第一个遇到的交点`c1`就是所求结点。

> 当然，事实上c3结点是共同结点，无法同时指向两个结点，也没必要让其真的指向b1或a1，会破坏链表结构。所以只需使用判断即可，指向A的指针到达尾结点就指向B的头结点；指向B的指针到达尾结点，就让其指向A的头结点。

时间复杂度：O(m+n)

空间复杂度：O(1)

#### 流程

1. 初始指针分别lA和lB分别指向A和B的起始结点
2. 同步遍历
    1. 如果遇到相同结点就返回该结点
    2. lA为空，lB不为空，则lA指向B的头结点
    3. lB为空，lA不为空，则lB指向A的头结点
3. lA和lB都为空，无公共交点，返回空
